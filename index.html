<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>中秋畫圓小遊戲</title>
  <style>
    :root {
      --bg: #0f1320;
      --panel: #161b2e;
      --accent: #ffd54f;
      --text: #e6e9f0;
      --muted: #9aa3b2;
      --stroke: #8ecae6;
      --stroke-dark: #219ebc;
      --danger: #ef476f;
      --success: #06d6a0;
    }
            
    html, body {
      height: 100%;
      margin: 0;
      /* 以本地圖片作為背景，並加上暗色疊層提升可讀性 */
      background:
        linear-gradient(rgba(8,12,22,0.55), rgba(8,12,22,0.55)),
        url('img/Background.png') center / cover no-repeat fixed;
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, "PingFang TC", "Microsoft JhengHei", sans-serif;
    }

    .app {
      max-width: 960px;
      margin: 0 auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .title {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      letter-spacing: 0.5px;
    }

    .moon {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #fff7d1, #f7d77e);
      box-shadow: 0 0 24px rgba(255, 213, 79, 0.5);
    }

    .panel {
      background: rgba(22, 27, 46, 0.8);
      backdrop-filter: blur(6px);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 12px;
    }

    .stats {
      display: flex;
      align-items: center;
      gap: 14px;
      flex-wrap: wrap;
    }

    .score {
      font-size: 18px;
      font-weight: 700;
      color: var(--accent);
    }

    .inputType {
      font-size: 14px;
      color: var(--muted);
    }

    .actions {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    button {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.15);
      background: linear-gradient(180deg, #223054, #19223c);
      color: var(--text);
      padding: 8px 14px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.2s ease;
    }
    button:hover { box-shadow: 0 6px 18px rgba(0,0,0,0.3); }
    button:active { transform: translateY(1px); }

    .canvas-wrap {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.08);
    }

    /* 以 vh 自適應高度，並隨寬度縮放 */
    canvas {
      display: block;
      width: 100%;
      height: 58vh;
      background: linear-gradient(180deg, #0b1020, #0f1526);
      touch-action: none; /* 啟用 Pointer Events 的多裝置防捲動 */
    }

    .hint {
      font-size: 14px;
      color: var(--muted);
      line-height: 1.6;
    }

    .footer {
      font-size: 13px;
      color: var(--muted);
      text-align: center;
    }

    @media (max-width: 600px) {
      .score { font-size: 16px; }
      canvas { height: 60vh; }
    }

    /* 登入覆蓋層 */
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 12px;
      background: rgba(10, 14, 26, 0.72);
      backdrop-filter: blur(4px);
      border-top: 1px solid rgba(255,255,255,0.06);
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .overlay h3 { margin: 0; }
    .overlay p { margin: 0; color: var(--muted); font-size: 14px; }

    .discord {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px; /* 適當水平間距 */
      padding: 8px 16px; /* 讓文字與圖標留出空間 */
      line-height: 1; /* 消除基線差，確保垂直置中 */
      font-size: 14px;
      background: linear-gradient(180deg, #4956f0, #3540c9);
      border-color: rgba(255,255,255,0.2);
    }
    .discord svg {
      width: 18px;
      height: 18px;
      display: block; /* 移除 SVG 內建基線空隙，避免偏移 */
      transform: translateY(1.5px); /* 視覺微調，讓圖標更居中 */
      flex-shrink: 0;
    }

    .user {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .avatar {
      width: 24px; height: 24px; border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.25);
    }
    .avatar-sm {
      width: 20px; height: 20px; border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.25);
      flex-shrink: 0;
    }
    /* 排行榜樣式 */
    .board {
      width: 100%;
      border-collapse: collapse;
    }
    .board th, .board td {
      border-bottom: 1px solid rgba(255,255,255,0.08);
      padding: 8px 10px;
      font-size: 14px;
    }
    .board th { text-align: left; color: var(--muted); font-weight: 600; }
    .board tr:hover td { background: rgba(255,255,255,0.03); }
    .rank { width: 64px; font-weight: 700; color: var(--accent); }
    .name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .score-col { width: 120px; font-weight: 700; }

    /* 排行榜彈窗 */
    .modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(10,14,26,0.55);
      backdrop-filter: blur(4px);
      z-index: 1000;
    }
    .modal.show { display: flex; }
    .modal-content {
      width: min(920px, 92vw);
      max-height: 80vh;
      overflow: auto;
      background: rgba(22,27,46,0.92);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 14px;
      box-shadow: 0 18px 48px rgba(0,0,0,0.4);
      padding: 12px;
    }
    .modal-header {
      display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;
    }
    .close-btn { background: #2a324f; }
  </style>
</head>
<body>
  <div class="app">
    <div class="header">
      <div class="title"><div class="moon"></div>中秋畫圓小遊戲</div>
      <div class="actions">
        <button id="boardBtn" title="查看全球排行榜">排行榜</button>
        <button id="resetBtn" title="清空畫布並重新繪製">重新繪製</button>
        <button id="loginBtn" class="discord" title="使用 Discord 登入">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="#fff"><path d="M20.317 4.369A18.14 18.14 0 0 0 16.558 3c-.2.367-.433.845-.593 1.228a17.2 17.2 0 0 0-5.93 0c-.16-.383-.393-.86-.593-1.228-1.39.254-2.78.717-3.76 1.369-2.395 3.48-3.042 6.89-2.715 10.256 1.573 1.166 3.085 1.875 4.573 2.343.359-.493.679-1.02.96-1.572-.53-.2-1.039-.44-1.512-.72.127-.093.252-.19.372-.289 2.913 1.37 6.06 1.37 8.972 0 .12.098.245.196.372.29-.473.28-.982.52-1.513.72.28.552.601 1.078.96 1.571 1.49-.468 3.002-1.177 4.575-2.343.39-4.07-.67-7.39-2.854-10.256zM9.25 12.705c-.846 0-1.54-.77-1.54-1.716s.685-1.716 1.54-1.716c.856 0 1.55.77 1.54 1.716s-.694 1.716-1.54 1.716zm5.5 0c-.846 0-1.54-.77-1.54-1.716s.685-1.716 1.54-1.716c.856 0 1.55.77 1.54 1.716s-.694 1.716-1.54 1.716z"/></svg>
          使用 Discord 登入
        </button>
        <button id="logoutBtn" title="登出" style="display:none">登出</button>
      </div>
    </div>

    <!-- 排行榜彈窗（獨立不影響版面） -->
    <div id="boardModal" class="modal" aria-hidden="true" role="dialog" aria-label="全球排行榜">
      <div class="modal-content">
        <div class="modal-header">
          <div style="font-weight:700;">排行榜（最高分）</div>
          <div style="display:flex;align-items:center;gap:8px;">
            <div style="font-size:12px;color:var(--muted);">每10秒自動刷新</div>
            <button id="boardClose" class="close-btn" title="關閉">返回</button>
          </div>
        </div>
        <table class="board">
          <thead>
            <tr>
              <th class="rank">排名</th>
              <th>玩家</th>
              <th class="score-col">最高分</th>
            </tr>
          </thead>
          <tbody id="leaderboardBody"></tbody>
        </table>
      </div>
    </div>
    <div class="panel stats">
      <div class="score">分數：<span id="scoreValue">0</span></div>
      <div class="inputType">輸入方式：<span id="inputType">自動偵測</span></div>
    </div>

    <div class="canvas-wrap">
      <canvas id="gameCanvas"></canvas>
      <div id="loginOverlay" class="overlay" aria-hidden="true">
        <h3>登入以開始遊戲</h3>
        <p>此遊戲需要使用 Discord 登入才能進行繪圖與評分。</p>
        <button id="overlayLoginBtn" class="discord">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="#fff"><path d="M20.317 4.369A18.14 18.14 0 0 0 16.558 3c-.2.367-.433.845-.593 1.228a17.2 17.2 0 0 0-5.93 0c-.16-.383-.393-.86-.593-1.228-1.39.254-2.78.717-3.76 1.369-2.395 3.48-3.042 6.89-2.715 10.256 1.573 1.166 3.085 1.875 4.573 2.343.359-.493.679-1.02.96-1.572-.53-.2-1.039-.44-1.512-.72.127-.093.252-.19.372-.289 2.913 1.37 6.06 1.37 8.972 0 .12.098.245.196.372.29-.473.28-.982.52-1.513.72.28.552.601 1.078.96 1.571 1.49-.468 3.002-1.177 4.575-2.343.39-4.07-.67-7.39-2.854-10.256zM9.25 12.705c-.846 0-1.54-.77-1.54-1.716s.685-1.716 1.54-1.716c.856 0 1.55.77 1.54 1.716s-.694 1.716-1.54 1.716zm5.5 0c-.846 0-1.54-.77-1.54-1.716s.685-1.716 1.54-1.716c.856 0 1.55.77 1.54 1.716s-.694 1.716-1.54 1.716z"/></svg>
          使用 Discord 登入
        </button>
      </div>
    </div>

    <div class="panel hint">
      提示：用手指或滑鼠在畫布中畫出一個圓，放開即評分。<br/>
    </div>

    <div class="panel" id="boardPanelBottom" style="display:none;">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;">
        <div style="font-weight:700;">排行榜</div>
        <div style="font-size:12px;color:var(--muted);">每10秒自動刷新</div>
      </div>
      <table class="board">
        <thead>
          <tr>
            <th class="rank">排名</th>
            <th>玩家</th>
            <th class="score-col">最高分</th>
          </tr>
        </thead>
        <tbody id="leaderboardBodyBottom"></tbody>
      </table>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('scoreValue');
    const inputTypeEl = document.getElementById('inputType');
    const resetBtn = document.getElementById('resetBtn');
    const loginBtn = document.getElementById('loginBtn');
    const overlayLoginBtn = document.getElementById('overlayLoginBtn');
    const loginOverlay = document.getElementById('loginOverlay');
    const logoutBtn = document.getElementById('logoutBtn');
    const leaderboardBody = document.getElementById('leaderboardBody');
    const boardBtn = document.getElementById('boardBtn');
    const boardModal = document.getElementById('boardModal');
    const boardClose = document.getElementById('boardClose');

    // Discord OAuth2（Implicit Grant）設定
    const DISCORD_CLIENT_ID = '1423972212196511816';
    const REDIRECT_URI = window.location.origin + '/';
    const OAUTH_SCOPE = 'identify';
    // Leaderboard API 設定
    // 預設指向 Render 後端；可用 ?api= 覆寫（支援 local 與 render 別名），在本機開發時也可明確指定。
    let API_BASE = 'https://mid-autumn-backend.onrender.com/api';
    (() => {
      const isLocalHost = ['localhost','127.0.0.1'].includes(location.hostname);
      const override = new URLSearchParams(location.search).get('api');
      if (override) {
        if (override === 'local') {
          API_BASE = 'http://localhost:8001/api';
        } else if (override === 'render') {
          API_BASE = 'https://mid-autumn-backend.onrender.com/api';
        } else {
          API_BASE = override; // 允許自定義完整 URL
        }
      } else if (isLocalHost) {
        // 本機預設仍可走本地端（若本地服務未開啟，程式會在 fetch 失敗時回退）
        API_BASE = 'http://localhost:8001/api';
      }
    })();
    let currentUser = null;
    let refreshTimer = null;

    function randomState(len = 32) {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      let s = '';
      for (let i = 0; i < len; i++) s += chars[Math.floor(Math.random() * chars.length)];
      return s;
    }

    function buildDiscordLoginUrl() {
      if (!DISCORD_CLIENT_ID || DISCORD_CLIENT_ID.includes('請填入')) {
        alert('請先將程式中的 DISCORD_CLIENT_ID 替換為你的應用程式 Client ID');
        return null;
      }
      const state = randomState(24);
      sessionStorage.setItem('oauth_state', state);
      const params = new URLSearchParams({
        client_id: DISCORD_CLIENT_ID,
        redirect_uri: REDIRECT_URI,
        response_type: 'token', // Implicit grant（無需 client secret）
        scope: OAUTH_SCOPE,
        state,
        prompt: 'consent'
      });
      return `https://discord.com/oauth2/authorize?${params.toString()}`;
    }

    function getTokenFromHash() {
      const frag = new URLSearchParams(window.location.hash.slice(1));
      const accessToken = frag.get('access_token');
      const tokenType = frag.get('token_type');
      const state = frag.get('state');
      return { accessToken, tokenType, state };
    }

    async function fetchMe(accessToken, tokenType) {
      const res = await fetch('https://discord.com/api/users/@me', {
        headers: { authorization: `${tokenType} ${accessToken}` }
      });
      if (!res.ok) throw new Error('取得使用者資訊失敗');
      return res.json();
    }

    function setAuthUI(user) {
      // 顯示使用者資訊、切換按鈕
      loginOverlay.style.display = 'none';
      logoutBtn.style.display = 'inline-block';
      loginBtn.style.display = 'none';
      const statsPanel = document.querySelector('.panel.stats');
      let userSpan = document.getElementById('userInfo');
      if (!userSpan) {
        userSpan = document.createElement('div');
        userSpan.id = 'userInfo';
        userSpan.className = 'user';
        statsPanel.appendChild(userSpan);
      }
      const fallbackIndex = (function(){
        const d = (user && typeof user.discriminator !== 'undefined') ? String(user.discriminator) : String(user.id || '').slice(-1);
        const n = parseInt(d, 10);
        return isNaN(n) ? 0 : (n % 5);
      })();
      const avatarUrl = user.avatar
        ? `https://cdn.discordapp.com/avatars/${user.id}/${user.avatar}.png?size=64`
        : `https://cdn.discordapp.com/embed/avatars/${fallbackIndex}.png`;
      userSpan.innerHTML = `<img class="avatar" alt="avatar" src="${avatarUrl}"/> <span>${user.global_name || user.username}</span>`;
      currentUser = { id: user.id, name: user.global_name || user.username, avatar: avatarUrl };
    }

    function clearAuthUI() {
      loginOverlay.style.display = 'flex';
      logoutBtn.style.display = 'none';
      loginBtn.style.display = 'inline-flex';
      const userSpan = document.getElementById('userInfo');
      if (userSpan) userSpan.remove();
      currentUser = null;
    }

    async function initAuth() {
      // 優先使用 sessionStorage 中的 token
      let accessToken = sessionStorage.getItem('access_token');
      let tokenType = sessionStorage.getItem('token_type');

      const { accessToken: at, tokenType: tt, state } = getTokenFromHash();
      if (at && tt) {
        // 驗證 state 防 CSRF
        const expectedState = sessionStorage.getItem('oauth_state');
        if (!expectedState || expectedState !== state) {
          // 狀態不一致，忽略此次登入
          window.location.hash = '';
        } else {
          accessToken = at; tokenType = tt;
          sessionStorage.setItem('access_token', accessToken);
          sessionStorage.setItem('token_type', tokenType);
          window.location.hash = '';
        }
      }

      if (accessToken && tokenType) {
        try {
          const me = await fetchMe(accessToken, tokenType);
          setAuthUI(me);
          return true;
        } catch (err) {
          console.error(err);
          sessionStorage.removeItem('access_token');
          sessionStorage.removeItem('token_type');
          clearAuthUI();
          return false;
        }
      } else {
        clearAuthUI();
        return false;
      }
    }

    function login() {
      const url = buildDiscordLoginUrl();
      if (url) window.location.href = url;
    }

    function logout() {
      sessionStorage.removeItem('access_token');
      sessionStorage.removeItem('token_type');
      clearAuthUI();
      // 清空畫布狀態
      points = [];
      scoreEl.textContent = '0';
      drawBackground();
    }

    async function fetchLeaderboard() {
      try {
        const res = await fetch(`${API_BASE}/leaderboard`);
        if (!res.ok) throw new Error('排行榜取得失敗');
        const data = await res.json();
        renderLeaderboard(data.items || []);
      } catch (err) {
        console.error(err);
        // 失敗時回退至本機 API（若目前不是本機）
        if (!API_BASE.startsWith('http://localhost:8001')) {
          try {
            const fallback = 'http://localhost:8001/api';
            const res2 = await fetch(`${fallback}/leaderboard`);
            if (res2.ok) {
              const data2 = await res2.json();
              API_BASE = fallback; // 後續請求改用本機
              renderLeaderboard(data2.items || []);
            }
          } catch (err2) {
            console.error('fallback 失敗', err2);
          }
        }
      }
    }

    function renderLeaderboard(items) {
      leaderboardBody.innerHTML = '';
      items.forEach((it) => {
        const tr = document.createElement('tr');
        const avatar = it.avatar || (currentUser && currentUser.id === String(it.user_id) ? currentUser.avatar : 'https://cdn.discordapp.com/embed/avatars/0.png');
        tr.innerHTML = `
          <td class="rank">${it.rank}</td>
          <td class="name"><span style="display:inline-flex;align-items:center;gap:8px;"><img class="avatar-sm" alt="avatar" src="${avatar}"/> ${escapeHtml(it.name || it.user_id || '未知')}</span></td>
          <td class="score-col">${Math.round(it.score || 0)}</td>
        `;
        leaderboardBody.appendChild(tr);
      });
    }

    function escapeHtml(str){
      return String(str).replace(/[&<>\"]/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;'}[s]));
    }

    async function submitScore(score) {
      if (!currentUser) return;
      try {
        const res = await fetch(`${API_BASE}/leaderboard/submit`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ user_id: currentUser.id, name: currentUser.name, score: Number(score), avatar: currentUser.avatar })
        });
        if (!res.ok) throw new Error('提交分數失敗');
        await res.json();
        fetchLeaderboard();
      } catch (err) {
        console.error(err);
        // 失敗時回退至本機 API（若目前不是本機）
        if (!API_BASE.startsWith('http://localhost:8001')) {
          try {
            const fallback = 'http://localhost:8001/api';
            const res2 = await fetch(`${fallback}/leaderboard/submit`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ user_id: currentUser.id, name: currentUser.name, score: Number(score), avatar: currentUser.avatar })
            });
            if (res2.ok) {
              API_BASE = fallback;
              await res2.json();
              fetchLeaderboard();
            }
          } catch (err2) {
            console.error('fallback 提交失敗', err2);
          }
        }
      }
    }

    let isDrawing = false;
    let points = []; // {x, y, t}
    let lastPointerType = '未知';

    const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));

    function resizeCanvas() {
      const { clientWidth, clientHeight } = canvas;
      const w = Math.max(320, Math.floor(clientWidth));
      const h = Math.max(240, Math.floor(clientHeight));
      canvas.width = w * DPR;
      canvas.height = h * DPR;
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      drawBackground();
      redrawStroke();
    }

    function drawBackground() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // 暗色格線作為參考
      const w = canvas.width / DPR;
      const h = canvas.height / DPR;
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      for (let x = 0; x < w; x += 24) {
        ctx.fillRect(x, 0, 1, h);
      }
      for (let y = 0; y < h; y += 24) {
        ctx.fillRect(0, y, w, 1);
      }
      ctx.restore();

      // 中心十字
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(w / 2, 8);
      ctx.lineTo(w / 2, h - 8);
      ctx.moveTo(8, h / 2);
      ctx.lineTo(w - 8, h / 2);
      ctx.stroke();
      ctx.restore();
    }

    function redrawStroke() {
      if (points.length < 2) return;
      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.lineWidth = 4;
      ctx.strokeStyle = '#8ecae6';
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left);
      const y = (e.clientY - rect.top);
      return { x, y };
    }

    function startDraw(e) {
      // 未登入則不允許繪圖
      if (!sessionStorage.getItem('access_token')) {
        return;
      }
      e.preventDefault();
      lastPointerType = e.pointerType || '未知';
      inputTypeEl.textContent = lastPointerType === 'touch' ? '觸控' : (lastPointerType === 'mouse' ? '滑鼠' : '筆/未知');
      isDrawing = true;
      points = [];
      const p = getPos(e);
      points.push({ x: p.x, y: p.y, t: performance.now() });
      drawBackground();
    }

    function moveDraw(e) {
      if (!isDrawing) return;
      e.preventDefault();
      const p = getPos(e);
      const last = points[points.length - 1];
      const dx = p.x - last.x, dy = p.y - last.y;
      const dist2 = dx*dx + dy*dy;
      // 忽略極短距離以降低抖動與點數
      if (dist2 < 1.0) return;
      points.push({ x: p.x, y: p.y, t: performance.now() });
      // 僅增量描線，提高效率
      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.lineWidth = 4;
      ctx.strokeStyle = '#8ecae6';
      ctx.beginPath();
      ctx.moveTo(last.x, last.y);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
      ctx.restore();
    }

    function endDraw(e) {
      if (!isDrawing) return;
      e.preventDefault();
      isDrawing = false;
      // 最後加入一點（避免指針抬起漏記）
      const p = getPos(e);
      const last = points[points.length - 1];
      const dx = p.x - last.x, dy = p.y - last.y;
      if (dx*dx + dy*dy > 1.0) {
        points.push({ x: p.x, y: p.y, t: performance.now() });
      }
      // 計算分數
      const score = evaluateScore(points);
      scoreEl.textContent = String(Math.round(score));
      submitScore(score);
      // 畫出首尾連線（視覺參考，不影響評分）
      if (points.length > 2) {
        ctx.save();
        ctx.strokeStyle = 'rgba(6,214,160,0.55)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
        ctx.stroke();
        ctx.restore();
      }
    }

    canvas.addEventListener('pointerdown', startDraw, { passive: false });
    canvas.addEventListener('pointermove', moveDraw, { passive: false });
    window.addEventListener('pointerup', endDraw, { passive: false });
    window.addEventListener('pointercancel', endDraw, { passive: false });

    // 工具函式
    function dist(a, b) {
      const dx = a.x - b.x, dy = a.y - b.y;
      return Math.hypot(dx, dy);
    }

    function mean(arr) {
      return arr.reduce((s, v) => s + v, 0) / arr.length;
    }

    function std(arr) {
      const m = mean(arr);
      const v = arr.reduce((s, v) => s + (v - m) * (v - m), 0) / arr.length;
      return Math.sqrt(v);
    }

    function evaluateScore(pts) {
      if (!pts || pts.length < 24) return 0; // 太短不評高分

      // 1) 圓度：以質心估中心，半徑標準差/平均半徑
      const cx = mean(pts.map(p => p.x));
      const cy = mean(pts.map(p => p.y));
      const radii = pts.map(p => Math.hypot(p.x - cx, p.y - cy));
      const rMean = mean(radii);
      const rStd = std(radii);
      const roundnessRatio = rStd / Math.max(1e-6, rMean); // 越小越圓
      const roundnessScore = 100 * Math.exp(-3.2 * roundnessRatio);

      // 2) 閉合度：首尾距離 / 平均半徑
      const dClose = dist(pts[0], pts[pts.length - 1]) / Math.max(1e-6, rMean);
      const closedScore = 100 * Math.exp(-4.0 * dClose);

      // 3) 平滑度：相鄰線段角度變化的變異度
      const segs = [];
      for (let i = 1; i < pts.length; i++) {
        const dx = pts[i].x - pts[i-1].x;
        const dy = pts[i].y - pts[i-1].y;
        const len2 = dx*dx + dy*dy;
        if (len2 < 1.0) continue; // 過短忽略
        segs.push({ dx, dy });
      }
      if (segs.length < 8) return Math.round((roundnessScore * 0.6 + closedScore * 0.4));
      const angles = segs.map(s => Math.atan2(s.dy, s.dx));
      const deltas = [];
      for (let i = 1; i < angles.length; i++) {
        let d = angles[i] - angles[i-1];
        // 正規化到 [-pi, pi]
        while (d > Math.PI) d -= 2*Math.PI;
        while (d < -Math.PI) d += 2*Math.PI;
        deltas.push(Math.abs(d));
      }
      const avgDelta = mean(deltas);
      const stdDelta = std(deltas);
      const smoothnessRatio = stdDelta / Math.max(1e-6, avgDelta); // 越小越平滑
      const smoothnessScore = 100 * Math.exp(-3.0 * smoothnessRatio);

      // 綜合分數（可微調權重）
      const total = roundnessScore * 0.4 + closedScore * 0.3 + smoothnessScore * 0.3;
      // 小圖形或半徑過小時給保守分數
      if (rMean < 30) return Math.min(40, total);
      return Math.max(0, Math.min(100, total));
    }

    resetBtn.addEventListener('click', () => {
      points = [];
      scoreEl.textContent = '0';
      drawBackground();
    });

    loginBtn.addEventListener('click', login);
    overlayLoginBtn.addEventListener('click', login);
    logoutBtn.addEventListener('click', logout);
    boardBtn.addEventListener('click', () => {
      boardModal.classList.add('show');
      boardModal.setAttribute('aria-hidden','false');
      fetchLeaderboard();
    });
    boardClose.addEventListener('click', () => {
      boardModal.classList.remove('show');
      boardModal.setAttribute('aria-hidden','true');
    });
    boardModal.addEventListener('click', (e) => {
      if (e.target === boardModal) {
        boardModal.classList.remove('show');
        boardModal.setAttribute('aria-hidden','true');
      }
    });
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && boardModal.classList.contains('show')) {
        boardModal.classList.remove('show');
        boardModal.setAttribute('aria-hidden','true');
      }
    });

    window.addEventListener('resize', resizeCanvas);
    // 初始
    resizeCanvas();
    drawBackground();
    initAuth();
    fetchLeaderboard();
    refreshTimer = setInterval(fetchLeaderboard, 10000);
  </script>
</body>
</html>